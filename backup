import os
import io
import csv
from datetime import datetime, date
from functools import wraps
from dateutil.relativedelta import relativedelta
from flask import (
    Flask, render_template, request, redirect, url_for,
    flash, send_from_directory, jsonify, abort, Response
)
from flask_login import (
    LoginManager, login_user, logout_user,
    login_required, current_user, UserMixin
)
from werkzeug.security import generate_password_hash, check_password_hash
from mpesa_handler import process_direct_payment
from flask import Flask, send_from_directory
from dotenv import load_dotenv
load_dotenv()
from extensions import db
from mpesa_handler import mpesa_bp, _connect


# -----------------------
# Base setup
# -----------------------
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DB_PATH = os.path.join(BASE_DIR, "rentana_full.db")
APK_FOLDER = os.path.join(BASE_DIR, "static", "apk")

app = Flask(__name__, static_folder="static", template_folder="templates")
app.config.from_object("config")    
app.config["SECRET_KEY"] = os.environ.get("RENTANA_SECRET") or "change-me-in-prod"
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL") or f"sqlite:///{DB_PATH}"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
app.config["MAX_CONTENT_LENGTH"] = 20 * 1024 * 1024

# -----------------------
# Initialize DB + Login Manager
# -----------------------
db.init_app(app)
login_manager = LoginManager(app)
login_manager.login_view = "login"
login_manager.login_message_category = "warning"

# ‚úÖ Automatically create database tables on startup (fixes ‚Äúno such table: user‚Äù)
with app.app_context():
    db.create_all()

# -----------------------
# Import and register blueprints AFTER db exists
# -----------------------
from landlord_settings import landlord_settings_bp  # uses db from app.py
app.register_blueprint(landlord_settings_bp)

# -----------------------
# Models
# -----------------------
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(256), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(256), nullable=False)
    is_admin = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # üîπ Relationships
    tenants = db.relationship("Tenant", backref="owner", cascade="all, delete-orphan")
    audit_logs = db.relationship("AuditLog", backref="user", cascade="all, delete-orphan")

    # üí≥ Payment Settings (Landlord Preferences)
    payment_method = db.Column(db.String(50), nullable=True)   # "SendMoney", "Paybill", or "Till"
    paybill_number = db.Column(db.String(30), nullable=True)
    till_number = db.Column(db.String(30), nullable=True)
    phone_number = db.Column(db.String(20), nullable=True)     # for Send Money (e.g. 2547xxxxxxx)

    def set_password(self, pwd: str):
        self.password_hash = generate_password_hash(pwd)

    def check_password(self, pwd: str) -> bool:
        return check_password_hash(self.password_hash, pwd)

    def __repr__(self):
        return f"<User {self.email} | method={self.payment_method}>"


class Tenant(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    owner_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    name = db.Column(db.String(180), nullable=False)
    phone = db.Column(db.String(80), nullable=False)
    national_id = db.Column(db.String(80))
    house_no = db.Column(db.String(80), nullable=False)
    monthly_rent = db.Column(db.Float, nullable=False, default=0.0)
    move_in_date = db.Column(db.Date, nullable=False, default=date.today)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    payments = db.relationship("Payment", backref="tenant", cascade="all, delete-orphan")

    def total_paid(self) -> float:
        return sum((p.amount or 0.0) for p in self.payments) if self.payments else 0.0

    def months_since_move_in(self, upto: date = None) -> int:
        upto = upto or date.today()
        if upto < self.move_in_date:
            return 0
        rd = relativedelta(upto, self.move_in_date)
        return rd.years * 12 + rd.months + (1 if rd.days >= 0 else 0)

    def total_due_since(self, upto: date = None) -> float:
        return self.months_since_move_in(upto) * float(self.monthly_rent)

    def balance_calc(self, upto: date = None) -> float:
        return round(self.total_due_since(upto) - self.total_paid(), 2)

    @property
    def balance(self) -> float:
        return self.balance_calc()


class Payment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    transaction_id = db.Column(db.String(50), unique=True, nullable=False)
    tenant_id = db.Column(db.Integer, db.ForeignKey('tenant.id'))
    amount = db.Column(db.Float, nullable=False)
    paid_at = db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())
    note = db.Column(db.String(255))

class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=True)
    action = db.Column(db.String(200), nullable=False)
    meta = db.Column(db.String(1000))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

#rada za mwisho
#-----------------------------------------------------------------------------------------------
@app.route("/mpesa_callback", methods=["POST"])
def mpesa_callback():
    """
    Safaricom Daraja will call this URL when payment is made.
    Handles both Paybill/Till (account-based) and Send Money (phone-based) payments.
    """
    try:
        data = request.get_json(force=True)
        print("üì© Received M-Pesa Callback:", data)

        # Extract details from M-Pesa JSON
        tx_id = data.get("TransID") or data.get("transID")
        amount = data.get("TransAmount") or data.get("transAmount")
        account = data.get("BillRefNumber") or data.get("billRefNumber")
        phone = data.get("MSISDN") or data.get("msisdn")

        # ‚úÖ Ensure required fields exist
        if not all([tx_id, amount]) or (not account and not phone):
            print("‚ö†Ô∏è Missing fields in callback:", data)
            return jsonify({"ResultCode": 1, "ResultDesc": "Missing fields"}), 400

        # ‚úÖ Route depending on whether account or phone is provided
        if account:
            print(f"üè¶ Processing Paybill/Till payment: account={account}, amount={amount}")
            result = process_direct_payment(account, amount, tx_id, note="M-Pesa Paybill Callback")
        else:
            print(f"üì± Processing Send Money payment: phone={phone}, amount={amount}")
            result = process_db_payment(phone, amount, tx_id, note="M-Pesa Send Money Callback")

        # ‚úÖ Response
        if result.get("ok"):
            print("‚úÖ Payment processed successfully:", result)
            return jsonify({
                "ResultCode": 0,
                "ResultDesc": "Payment processed successfully",
                "Receipt": result.get("receipt"),
                "TenantID": result.get("tenant_id")
            }), 200
        else:
            print("‚ùå Payment failed:", result)
            return jsonify({
                "ResultCode": 1,
                "ResultDesc": f"Payment not processed: {result.get('reason')}"
            }), 200

    except Exception as e:
        print("üí• Error handling M-Pesa callback:", e)
        return jsonify({"ResultCode": 1, "ResultDesc": "Server Error"}), 500

#-----------------------------------------------------------

# üîπ M-Pesa Payment Processing Helpers (Improved)
def process_db_payment(phone, amount, tx, note=""):
    """
    Handles M-Pesa Send Money / STK Push payments matched by phone number.
    Normalizes phone formats, prevents duplicates, and records payment + audit.
    """
    try:
        from extensions import db
        from app import Tenant, Payment, AuditLog

        print(f"üí∞ Processing payment: phone={phone}, amount={amount}, tx={tx}, note={note}")

        # Convert and sanitize amount
        try:
            amount = float(amount)
        except ValueError:
            print("‚ùå Invalid amount:", amount)
            return {"ok": False, "reason": "invalid_amount"}

        # Normalize phone format
        phone = str(phone).strip().replace(" ", "").replace("+", "")
        if phone.startswith("254"):
            phone = "0" + phone[3:]
        elif phone.startswith("7"):
            phone = "0" + phone
        elif not phone.startswith("0"):
            print("‚ö†Ô∏è Unrecognized phone format:", phone)

        print(f"üî¢ Normalized phone: {phone}")

        # Find tenant by phone
        tenant = Tenant.query.filter_by(phone=phone).first()
        if not tenant:
            print(f"‚ö†Ô∏è No tenant found with phone {phone}")
            return {"ok": False, "reason": "tenant_not_found", "phone": phone}

        # Prevent duplicate transactions
        if Payment.query.filter_by(transaction_id=tx).first():
            print(f"‚ö†Ô∏è Duplicate transaction ID detected: {tx}")
            return {"ok": False, "reason": "duplicate_transaction", "tx": tx}

        # Record payment
        payment = Payment(
            tenant_id=tenant.id,
            amount=amount,
            transaction_id=tx,
            note=note
        )
        db.session.add(payment)

        # Log audit trail
        audit = AuditLog(
            user_id=tenant.owner_id,
            action=f"Payment received from {tenant.name} ({tenant.phone})",
            meta=f"Amount={amount}, TxID={tx}, Note={note}"
        )
        db.session.add(audit)

        db.session.commit()

        print(f"‚úÖ Payment recorded: {tenant.name} paid KES {amount:.2f}. Balance={tenant.balance}")
        return {"ok": True, "tenant": tenant.name, "amount": amount, "tenant_id": tenant.id, "balance": tenant.balance}

    except Exception as e:
        print("üí• Error in process_db_payment:", e)
        db.session.rollback()
        return {"ok": False, "reason": str(e)}

# -----------------------------------------------------
#def process_payment(phone, amount, tx, note=""):
    """
    Handles payments matched by phone number (Send Money / STK Push).
    Automatically normalizes phone formats and logs all actions.
    """
    try:
        from models import db, Tenant, Payment, AuditLog

        print(f"‚úÖ Processing M-Pesa payment: phone={phone}, amount={amount}, tx={tx}, note={note}")

        # Convert and sanitize amount
        try:
            amount = float(amount)
        except ValueError:
            print("‚ùå Invalid amount:", amount)
            return {"ok": False, "reason": "invalid_amount"}

        # Normalize phone formats
        phone = str(phone).strip().replace(" ", "")
        if phone.startswith("+254"):
            phone = "0" + phone[4:]
        elif phone.startswith("254"):
            phone = "0" + phone[3:]
        elif phone.startswith("7"):
            phone = "0" + phone
        elif not phone.startswith("0"):
            print("‚ö†Ô∏è Unrecognized phone format:", phone)

        # Match tenant by phone
        tenant = Tenant.query.filter_by(phone=phone).first()
        if not tenant:
            print("‚ö†Ô∏è Tenant not found for phone:", phone)
            return {"ok": False, "reason": "tenant_not_found", "phone": phone}

        # Prevent duplicate transactions
        if Payment.query.filter_by(transaction_id=tx).first():
            print("‚ö†Ô∏è Duplicate transaction:", tx)
            return {"ok": False, "reason": "duplicate_transaction", "tx": tx}

        # Create payment record
        payment = Payment(
            tenant_id=tenant.id,
            amount=amount,
            transaction_id=tx,
            note=note
        )
        db.session.add(payment)

        # Create audit log
        audit = AuditLog(
            user_id=tenant.owner_id,
            action=f"Received payment KES {amount:.2f} from {tenant.name} ({tenant.phone})",
            meta=f"TxID={tx}, Note={note}"
        )
        db.session.add(audit)

        # Commit transaction
        db.session.commit()

        print(f"üíæ Recorded payment for {tenant.name}: +KES {amount:.2f} | New Total={tenant.total_paid()} | Balance={tenant.balance}")
        return {"ok": True, "tenant": tenant.name, "amount": amount, "balance": tenant.balance}

    except Exception as e:
        print("‚ùå Error processing payment:", e)
        db.session.rollback()
        return {"ok": False, "reason": str(e)}


#def process_direct_payment(account, amount, tx, note=""):
    """
    Handles payments matched by account number (House Number / Paybill).
    Typically used for Paybill or Till Number payments with 'account' reference.
    """
    try:
        from models import db, Tenant, Payment, AuditLog

        print(f"‚úÖ Processing direct M-Pesa payment: account={account}, amount={amount}, tx={tx}, note={note}")

        # Convert and validate amount
        try:
            amount = float(amount)
        except ValueError:
            print("‚ùå Invalid amount:", amount)
            return {"ok": False, "reason": "invalid_amount"}

        account = str(account).strip().upper()

        # Find tenant by house number
        tenant = Tenant.query.filter(db.func.upper(Tenant.house_no) == account).first()
        if not tenant:
            print("‚ö†Ô∏è Tenant not found for account:", account)
            return {"ok": False, "reason": "tenant_not_found", "account": account}

        # Prevent duplicate transactions
        if Payment.query.filter_by(transaction_id=tx).first():
            print("‚ö†Ô∏è Duplicate transaction:", tx)
            return {"ok": False, "reason": "duplicate_transaction", "tx": tx}

        # Record payment
        payment = Payment(
            tenant_id=tenant.id,
            amount=amount,
            transaction_id=tx,
            note=note
        )
        db.session.add(payment)

        # Log audit event
        audit = AuditLog(
            user_id=tenant.owner_id,
            action=f"Payment received for {tenant.name} (House {tenant.house_no})",
            meta=f"Amount={amount:.2f}, TxID={tx}, Note={note}"
        )
        db.session.add(audit)

        # Commit
        db.session.commit()

        print(f"üíæ Recorded payment for {tenant.name}: +KES {amount:.2f} | New Total={tenant.total_paid()} | Balance={tenant.balance}")
        return {"ok": True, "tenant": tenant.name, "amount": amount, "balance": tenant.balance}

    except Exception as e:
        print("‚ùå Error processing direct payment:", e)
        db.session.rollback()
        return {"ok": False, "reason": str(e)}


# -----------------------
# Login / audit helpers
# -----------------------
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


def audit(user, action: str, meta: str = ""):
    try:
        entry = AuditLog(user_id=(user.id if user else None), action=action, meta=str(meta))
        db.session.add(entry)
        db.session.commit()
    except Exception:
        db.session.rollback()


def ensure_apk_exists(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if not os.path.isdir(APK_FOLDER):
            flash("APK folder missing.", "danger")
            return redirect(url_for("dashboard"))
        apk_files = [f for f in os.listdir(APK_FOLDER) if f.lower().endswith(".apk")]
        if not apk_files:
            flash("No APK file found.", "warning")
            return redirect(url_for("dashboard"))
        kwargs["_apk_filename"] = apk_files[0]
        return func(*args, **kwargs)
    return wrapper


def owner_required(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        tenant_id = kwargs.get("tenant_id") or request.view_args.get("tenant_id") or request.form.get("tenant_id") or request.args.get("tenant_id")
        if not tenant_id:
            abort(400)
        tenant = Tenant.query.get(int(tenant_id))
        if not tenant:
            abort(404)
        if not current_user.is_authenticated:
            return redirect(url_for("login", next=request.path))
        if tenant.owner_id != current_user.id and not current_user.is_admin:
            flash("No permission.", "danger")
            return redirect(url_for("tenant_list"))
        kwargs["_tenant_obj"] = tenant
        return func(*args, **kwargs)
    return wrapper


# -----------------------
# Auth routes
# -----------------------
@app.route("/register", methods=["GET", "POST"])
def register():
    if current_user.is_authenticated:
        return redirect(url_for("dashboard"))
    if request.method == "POST":
        email = (request.form.get("email") or "").strip().lower()
        password = request.form.get("password") or ""
        confirm = request.form.get("confirm") or ""
        if not email or not password:
            flash("Email & password required.", "danger")
            return render_template("register.html")
        if password != confirm:
            flash("Passwords do not match.", "danger")
            return render_template("register.html")
        if User.query.filter_by(email=email).first():
            flash("Email exists. Login instead.", "warning")
            return redirect(url_for("login"))
        u = User(email=email)
        u.set_password(password)
        db.session.add(u)
        db.session.commit()
        audit(u, "user_registered", meta=f"email:{email}")
        flash("Registered. Please login.", "success")
        return redirect(url_for("login"))
    return render_template("register.html")


@app.route("/login", methods=["GET", "POST"])
def login():
    if current_user.is_authenticated:
        return redirect(url_for("dashboard"))
    if request.method == "POST":
        email = (request.form.get("email") or "").strip().lower()
        password = request.form.get("password") or ""
        user = User.query.filter_by(email=email).first()
        if not user or not user.check_password(password):
            flash("Invalid email or password.", "danger")
            return render_template("login.html", email=email)
        login_user(user)
        audit(user, "user_logged_in", meta=f"email:{email}")
        flash("Welcome back!", "success")
        return redirect(request.args.get("next") or url_for("dashboard"))
    return render_template("login.html")


@app.route("/logout")
@login_required
def logout():
    audit(current_user, "user_logged_out")
    logout_user()
    flash("Logged out.", "info")
    return redirect(url_for("login"))


#webhook
@app.route("/webhook/payment", methods=["POST"])
def mpesa_webhook():
    """
    Unified M-Pesa webhook handler.
    Works for:
      - STK Push (Lipa Na M-Pesa Online)
      - C2B Paybill/Till callbacks
      - Generic M-Pesa payloads
    """

    # --- Debug logging ---
    print("üì° Received webhook request:")
    print("üì© Headers:", dict(request.headers))
    print("üì® Raw Data:", request.data)

    # --- Parse payload safely ---
    try:
        payload = request.get_json(force=False, silent=True) \
            or request.form.to_dict() \
            or request.values.to_dict()
    except Exception:
        payload = {}

    if not payload:
        print("‚ö†Ô∏è Empty payload received.")
        return jsonify({"ok": False, "reason": "empty_payload"}), 400

    print("üîî Incoming M-Pesa Payload:", payload)

    # =============================
    # CASE 1: STK Push Callback
    # =============================
    try:
        body = payload.get("Body") or payload.get("body")
        if isinstance(body, str):
            body = json.loads(body)
        if body and isinstance(body, dict):
            stk = body.get("stkCallback") or body.get("StkCallback")
            if stk:
                result_code = stk.get("ResultCode")
                result_desc = stk.get("ResultDesc")
                metadata = stk.get("CallbackMetadata", {})
                items = metadata.get("Item", [])
                amount = receipt = phone = None

                for it in items:
                    name = (it.get("Name") or "").lower()
                    if "amount" in name:
                        amount = it.get("Value")
                    elif "receipt" in name:
                        receipt = it.get("Value")
                    elif "phone" in name:
                        phone = it.get("Value")

                print(f"üí∞ STK Push Callback: {phone=} {amount=} {receipt=} {result_code=}")

                if str(result_code) == "0":
                    resp = process_payment(phone, amount, receipt, note="daraja_stk")
                    return jsonify(resp)
                else:
                    return jsonify({
                        "ok": False,
                        "reason": "stk_failed",
                        "desc": result_desc
                    }), 400
    except Exception as e:
        print("‚ö†Ô∏è STK Parse Error:", e)

    # =============================
    # CASE 2: C2B Paybill/Till Callback
    # =============================
    try:
        data = payload
        if "Body" in payload and isinstance(payload["Body"], dict):
            for k, v in payload["Body"].items():
                if isinstance(v, dict):
                    data = v
                    break

        tx = (
            data.get("TransID") or data.get("TransactionID")
            or data.get("MpesaReceiptNumber") or data.get("ReceiptNumber")
            or data.get("TransactionReceipt")
        )
        amount = (
            data.get("Amount") or data.get("amount")
            or data.get("TransactionAmount") or data.get("TransAmount")
        )
        phone = (
            data.get("MSISDN") or data.get("Msisdn")
            or data.get("msisdn") or data.get("PhoneNumber")
            or data.get("phone")
        )
        account = (
            data.get("AccountNumber") or data.get("Account")
            or data.get("BillRefNumber") or data.get("AccountReference")
            or data.get("BillRef")
        )

        if tx and amount and (phone or account):
            print(f"üè¶ C2B Callback: {phone=} {account=} {amount=} {tx=}")
            if account:
                resp = process_direct_payment(account, amount, tx, note="daraja_c2b")
            else:
                resp = process_payment(phone, amount, tx, note="daraja_c2b")
            return jsonify(resp)
    except Exception as e:
        print("‚ö†Ô∏è C2B Parse Error:", e)

    # =============================
    # CASE 3: Generic / fallback handler
    # =============================
    try:
        phone = payload.get("sender") or payload.get("msisdn") or payload.get("phone")
        account = payload.get("account") or payload.get("Account") or payload.get("BillRefNumber")
        amount = payload.get("amount") or payload.get("Amount")
        tx = payload.get("tx_id") or payload.get("TransID") or f"MPESA_{int(datetime.utcnow().timestamp())}"

        if phone and amount:
            resp = process_payment(phone, amount, tx, note="generic")
            return jsonify(resp)
        if account and amount:
            resp = process_direct_payment(account, amount, tx, note="generic")
            return jsonify(resp)
    except Exception as e:
        print("‚ö†Ô∏è Generic Handler Error:", e)

    # =============================
    # CASE 4: Unrecognized payload
    # =============================
    print("‚ùå Unrecognized payload structure.")
    return jsonify({
        "ok": False,
        "reason": "unrecognized_payload",
        "payload_preview": list(payload.keys())
    }), 400


# =====================================
# ‚úÖ Helper Functions
# =====================================
#DUPLICATEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
##3def process_payment(phone, amount, receipt, note=""):
    """
    Process a normal M-Pesa payment (STK Push or C2B)
    """
    try:
        print(f"‚úÖ Payment received from {phone} - KES {amount} - Receipt {receipt} ({note})")
        # Example: Save to DB or trigger event
        # db.session.add(Payment(...))
        # db.session.commit()
        return {
            "ok": True,
            "type": "payment",
            "source": note,
            "phone": phone,
            "amount": amount,
            "receipt": receipt
        }
    except Exception as e:
        print("‚ùå Error saving payment:", e)
        return {"ok": False, "reason": str(e)}


#def process_direct_payment(account, amount, tx, note=""):
    """
    Process a direct Paybill/Till payment with account reference.
    """
    try:
        print(f"‚úÖ Payment received for account {account} - KES {amount} - TxID {tx} ({note})")
        # Example: Save to DB or credit account
        return {
            "ok": True,
            "type": "direct_payment",
            "source": note,
            "account": account,
            "amount": amount,
            "tx": tx
        }
    except Exception as e:
        print("‚ùå Error saving direct payment:", e)
        return {"ok": False, "reason": str(e)}
#manifesss

@app.route("/manifest.json")
def manifest():
    return send_from_directory('static', 'manifest.json', mimetype='application/manifest+json')


# Optional: health check
# ----------------------
@app.route("/webhook/health", methods=["GET"])
def health_check():
    return jsonify({"status": "ok", "message": "Webhook is alive"}), 200

# ----------------------
# Optional: simulate a test payment (offline)
# ----------------------
@app.route("/webhook/simulate", methods=["POST"])
def simulate_payment_endpoint():
    """
    Simulate a payment for testing offline or Phase 2 workflow.
    Payload: { "phone": "07...", "amount": 1000 } or { "account": "123456", "amount": 5000 }
    """
    payload = request.json or {}
    phone = payload.get("phone")
    account = payload.get("account")
    amount = payload.get("amount")
    if not amount:
        return jsonify({"ok": False, "reason": "missing_amount"}), 400

    try:
        amount = float(amount)
    except ValueError:
        return jsonify({"ok": False, "reason": "invalid_amount"}), 400

    if phone:
        from mpesa_handler import simulate_payment
        payment = simulate_payment(phone, amount)
        return jsonify({
            "ok": True,
            "type": "simulate_phone_payment",
            "tenant_id": getattr(payment, "tenant_id", None),
            "amount": amount
        })
    elif account:
        from mpesa_handler import simulate_direct_payment
        payments = simulate_direct_payment(account, amount)
        tenant_ids = [p.tenant_id for p in payments] if payments else []
        return jsonify({
            "ok": True,
            "type": "simulate_direct_payment",
            "tenant_ids": tenant_ids,
            "amount": amount
        })
    else:
        return jsonify({"ok": False, "reason": "missing_phone_or_account"}), 400

# -----------------------
# Settings
# -----------------------


#settingpayingg
@app.route('/settings/payment', methods=['GET', 'POST'])
@login_required
def settings_payment():
    # Only allow landlords
    if not getattr(current_user, "is_landlord", True):  # fallback True if attribute missing
        flash("Access denied.", "danger")
        return redirect(url_for('dashboard'))

    if request.method == "POST":
        paybill = (request.form.get("paybill_number") or "").strip()
        till = (request.form.get("till_number") or "").strip()
        phone = (request.form.get("phone_number") or "").strip()

        # Normalize digits
        import re
        def digits(n): return re.sub(r"\D", "", n or "")

        # Reset everything first
        current_user.payment_method = None
        current_user.paybill_number = None
        current_user.till_number = None
        current_user.phone_number = None

        # Assign based on which field is filled
        if paybill:
            current_user.payment_method = "Paybill"
            current_user.paybill_number = digits(paybill)
        elif till:
            current_user.payment_method = "Till"
            current_user.till_number = digits(till)
        elif phone:
            current_user.payment_method = "SendMoney"
            current_user.phone_number = digits(phone)

        db.session.commit()
        flash("Payment settings updated successfully.", "success")
        return redirect(url_for('settings_payment'))

    return render_template(
        "settings_payment.html",
        paybill=current_user.paybill_number,
        till=current_user.till_number,
        phone=current_user.phone_number,
        payment_method=current_user.payment_method  # send current method to template
    )

# -----------------------
# Dashboard


@app.route("/")
@login_required
def dashboard():
    # just render the dashboard template
    return render_template("dashboard.html")
# -----------------------
@app.route("/dashboard_data")
@login_required
def dashboard_data():
    """
    Return JSON data for the landlord dashboard, including:
    - Tenants list
    - Recent payments
    - Totals (expected, collected, outstanding)
    - Landlord payment method
    """
    # Fetch tenants owned by the logged-in landlord
    tenants = Tenant.query.filter_by(owner_id=current_user.id).order_by(Tenant.name).all()

    # Fetch recent payments
    payments = (
        Payment.query.join(Tenant)
        .filter(Tenant.owner_id == current_user.id)
        .order_by(Payment.paid_at.desc())
        .limit(10)
        .all()
    )

    # Compute totals
    total_expected = sum(t.total_due_since() for t in tenants)
    total_collected = sum(t.total_paid() for t in tenants)
    total_outstanding = round(total_expected - total_collected, 2)
    collected_percent = (total_collected / total_expected * 100) if total_expected else 0

    # Use current_user.payment_method directly
    payment_method = current_user.payment_method or "Not set"

    # Prepare JSON data
    data = {
        "total_tenants": len(tenants),
        "total_expected": total_expected,
        "total_collected": total_collected,
        "total_outstanding": total_outstanding,
        "collected_percent": round(collected_percent, 2),
        "payment_method": payment_method,
        "tenants": [
            {
                "id": t.id,
                "name": t.name,
                "phone": t.phone,
                "house_no": t.house_no,
                "monthly_rent": t.monthly_rent,
                "total_paid": t.total_paid(),
                "total_due": t.total_due_since(),
                "balance": t.balance
            } for t in tenants
        ],
        "payments": [
            {
                "id": p.id,
                "tenant_name": p.tenant.name,
                "amount": p.amount,
                "note": p.note,
                "paid_at": p.paid_at.strftime("%Y-%m-%d %H:%M")
            } for p in payments
        ],
    }

    return jsonify(data)


#payment type
# -----------------------

@app.route("/update_payment_settings", methods=["POST"])
@login_required
def update_payment_settings():
    method = (request.form.get("payment_method") or "").strip()  # normalize input
    account_number = (request.form.get("account_number") or "").strip()

    user = current_user

    # Save payment method explicitly
    if method in ["Paybill", "Till", "SendMoney"]:
        user.payment_method = method
    else:
        flash("Invalid payment method.", "danger")
        return redirect(url_for("dashboard"))

    # Reset all numbers first
    user.paybill_number = None
    user.till_number = None
    user.phone_number = None

    # Save the account/phone number based on method
    if method == "Paybill":
        user.paybill_number = account_number
    elif method == "Till":
        user.till_number = account_number
    else:  # SendMoney
        user.phone_number = account_number

    db.session.commit()
    flash("Payment settings updated successfully!", "success")
    return redirect(url_for("dashboard"))




# Tenants CRUD
# -----------------------
@app.route("/tenants")
@login_required
def tenant_list():
    q = (request.args.get("q") or "").strip()
    base_q = Tenant.query.filter_by(owner_id=current_user.id)
    if q:
        base_q = base_q.filter(
            (Tenant.name.ilike(f"%{q}%")) |
            (Tenant.phone.ilike(f"%{q}%")) |
            (Tenant.house_no.ilike(f"%{q}%"))
        )
    tenants = base_q.order_by(Tenant.name).all()
    return render_template("tenant_list.html", tenants=tenants, query=q)


@app.route("/tenant/add", methods=["GET", "POST"])
@login_required
def tenant_add():
    if request.method == "POST":
        try:
            move_in = request.form.get("move_in_date") or str(date.today())
            t = Tenant(
                owner_id=current_user.id,
                name=(request.form.get("name") or "").strip(),
                phone=(request.form.get("phone") or "").strip(),
                national_id=(request.form.get("national_id") or "").strip(),
                house_no=(request.form.get("house_no") or "").strip(),
                monthly_rent=float(request.form.get("monthly_rent") or 0),
                move_in_date=datetime.strptime(move_in, "%Y-%m-%d").date()
            )
        except Exception:
            flash("Invalid tenant data.", "danger")
            return render_template("add_tenant.html", form=request.form)
        db.session.add(t)
        db.session.commit()
        audit(current_user, "tenant_added", meta=f"id:{t.id}")
        flash("Tenant added.", "success")
        return redirect(url_for("dashboard"))
    return render_template("add_tenant.html")


@app.route("/tenant/<int:tenant_id>/edit", methods=["GET", "POST"])
@login_required
@owner_required
def tenant_edit(tenant_id, _tenant_obj=None):
    t = _tenant_obj
    if request.method == "POST":
        t.name = (request.form.get("name") or "").strip()
        t.phone = (request.form.get("phone") or "").strip()
        t.national_id = (request.form.get("national_id") or "").strip()
        t.house_no = (request.form.get("house_no") or "").strip()
        try:
            t.monthly_rent = float(request.form.get("monthly_rent") or t.monthly_rent)
        except ValueError:
            flash("Monthly rent must be a number.", "danger")
            return render_template("edit_tenants.html", tenant=t)
        move_in = request.form.get("move_in_date") or str(t.move_in_date)
        try:
            t.move_in_date = datetime.strptime(move_in, "%Y-%m-%d").date()
        except ValueError:
            flash("Move-in date must be YYYY-MM-DD.", "danger")
            return render_template("edit_tenants.html", tenant=t)
        db.session.commit()
        audit(current_user, "tenant_edited", meta=f"id:{t.id}")
        flash("Tenant updated.", "success")
        return redirect(url_for("tenant_list"))
    return render_template("edit_tenants.html", tenant=t)


@app.route("/tenant/<int:tenant_id>/delete", methods=["POST"])
@login_required
@owner_required
def tenant_delete(tenant_id, _tenant_obj=None):
    db.session.delete(_tenant_obj)
    db.session.commit()
    audit(current_user, "tenant_deleted", meta=f"id:{tenant_id}")
    flash("Tenant deleted.", "info")
    return redirect(url_for("tenant_list"))


# Bulk delete
@app.route("/tenants/bulk-delete", methods=["POST"])
@login_required
def tenant_bulk_delete():
    ids = request.form.getlist("tenant_ids")
    if not ids:
        flash("No tenants selected.", "warning")
        return redirect(url_for("tenant_list"))
    q = Tenant.query.filter(Tenant.id.in_(ids))
    if not current_user.is_admin:
        q = q.filter(Tenant.owner_id == current_user.id)
    tenants = q.all()
    count = len(tenants)
    for t in tenants:
        db.session.delete(t)
    db.session.commit()
    audit(current_user, "tenants_bulk_deleted", meta=f"ids:{','.join(ids)}")
    flash(f"{count} tenant(s) deleted.", "success")
    return redirect(url_for("tenant_list"))


# -----------------------
# Payments CRUD
# -----------------------
@app.route("/payment/add", methods=["GET", "POST"], endpoint="payment_add")
@login_required
@owner_required
def payment_add(_tenant_obj=None, tenant_id=None):
    tenant = _tenant_obj
    if request.method == "POST":
        try:
            amount = float(request.form.get("amount") or 0)
        except ValueError:
            flash("Amount must be a number.", "danger")
            return render_template("add_payment.html", tenant=tenant)
        note = (request.form.get("note") or "").strip()
        p = Payment(tenant_id=tenant.id, amount=amount, note=note)
        db.session.add(p)
        db.session.commit()
        audit(current_user, "payment_added", meta=f"payment_id:{p.id},tenant_id:{tenant.id}")
        flash(f"Payment recorded ({amount}).", "success")
        return redirect(url_for("dashboard"))
    return render_template("add_payment.html", tenant=tenant)


@app.route("/payment/<int:payment_id>/edit", methods=["GET", "POST"])
@login_required
def payment_edit(payment_id):
    p = Payment.query.get_or_404(payment_id)
    if p.tenant.owner_id != current_user.id and not current_user.is_admin:
        flash("Not authorized.", "danger")
        return redirect(url_for("tenant_list"))
    if request.method == "POST":
        try:
            p.amount = float(request.form.get("amount") or p.amount)
        except ValueError:
            flash("Amount must be a number.", "danger")
            return render_template("payment_edit.html", payment=p)
        p.note = request.form.get("note") or ""
        db.session.commit()
        audit(current_user, "payment_edited", meta=f"id:{p.id}")
        flash("Payment updated.", "success")
        return redirect(url_for("dashboard"))
    return render_template("payment_edit.html", payment=p)


@app.route("/payments")
@login_required
def payment_list():
    payments = (Payment.query.join(Tenant)
                .filter(Tenant.owner_id == current_user.id)
                .order_by(Payment.paid_at.desc())
                .all())
    return render_template("payment_list.html", payments=payments)


# Bulk pay
@app.route('/bulk_pay', methods=['POST'])
@login_required
def bulk_pay():
    tenant_ids = request.form.getlist('tenant_ids')
    amount_raw = request.form.get('amount')
    if not tenant_ids or not amount_raw:
        flash("Tenant(s) or amount missing.", "warning")
        return redirect(url_for("tenant_list"))
    try:
        amount = float(amount_raw)
    except ValueError:
        flash("Invalid amount.", "danger")
        return redirect(url_for("tenant_list"))
    created = 0
    for tid in tenant_ids:
        t = Tenant.query.get(int(tid))
        if t and (t.owner_id == current_user.id or current_user.is_admin):
            p = Payment(tenant_id=t.id, amount=amount, note="Bulk payment")
            db.session.add(p)
            created += 1
    db.session.commit()
    audit(current_user, "bulk_pay", meta=f"ids:{','.join(tenant_ids)},amount:{amount}")
    flash(f"Bulk payments created for {created} tenant(s).", "success")
    return redirect(url_for("dashboard"))


# -----------------------
# Exports
# -----------------------
def make_csv_response(csv_text: str, filename="export.csv"):
    return Response(csv_text, mimetype="text/csv",
                    headers={"Content-disposition": f"attachment; filename={filename}"})


@app.route("/export/tenants.csv")
@login_required
def export_tenants_csv():
    base_q = Tenant.query
    if not current_user.is_admin:
        base_q = base_q.filter_by(owner_id=current_user.id)
    si = io.StringIO()
    cw = csv.writer(si)
    cw.writerow(["id","name","phone","national_id","house_no","monthly_rent","move_in_date","total_paid","total_due","balance"])
    for t in base_q.order_by(Tenant.name).all():
        cw.writerow([
            t.id, t.name, t.phone, t.national_id, t.house_no,
            f"{t.monthly_rent:.2f}", t.move_in_date.isoformat(),
            f"{t.total_paid():.2f}", f"{t.total_due_since():.2f}", f"{t.balance:.2f}"
        ])
    return make_csv_response(si.getvalue(), "tenants_export.csv")


@app.route("/export/payments.csv")
@login_required
def export_payments_csv():
    base_q = Payment.query.join(Tenant)
    if not current_user.is_admin:
        base_q = base_q.filter(Tenant.owner_id == current_user.id)
    si = io.StringIO()
    cw = csv.writer(si)
    cw.writerow(["id","tenant_id","tenant_name","amount","note","paid_at"])
    for p in base_q.order_by(Payment.paid_at.desc()).all():
        cw.writerow([p.id, p.tenant_id, p.tenant.name, f"{p.amount:.2f}", p.note or "", p.paid_at.isoformat()])
    return make_csv_response(si.getvalue(), "payments_export.csv")


# -----------------------
# APK & PWA
# -----------------------
@app.route("/apk/download")
@login_required
@ensure_apk_exists
def apk_download(_apk_filename=None):
    return send_from_directory(APK_FOLDER, _apk_filename, as_attachment=True)


@app.route("/apk/latest")
@login_required
@ensure_apk_exists
def apk_latest(_apk_filename=None):
    return jsonify({"filename": _apk_filename, "url": url_for("apk_download")})


@app.route("/service-worker.js")
def service_worker():
    return send_from_directory(app.static_folder, "service-worker.js")


# -----------------------
# Context processors / errors / CLI
# -----------------------
@app.context_processor
def inject_now():
    return {"current_year": datetime.now().year, "today": date.today(), "date": date, "datetime": datetime}


@app.errorhandler(403)
def forbidden(e):
    return render_template("error.html", code=403, message="Forbidden"), 403

@app.errorhandler(404)
def not_found(e):
    return render_template("error.html", code=404, message="Not Found"), 404

@app.errorhandler(500)
def server_error(e):
    return render_template("error.html", code=500, message="Server Error"), 500


@app.cli.command("init-db")
def init_db():
    db.create_all()
    print("Database initialized at:", DB_PATH)


@app.cli.command("create-admin")
def create_admin():
    import getpass
    email = input("Admin email: ").strip().lower()
    if not email:
        print("Email required.")
        return
    if User.query.filter_by(email=email).first():
        print("User exists.")
        return
    pwd = getpass.getpass("Password: ")
    pwd2 = getpass.getpass("Confirm Password: ")
    if pwd != pwd2:
        print("Passwords do not match.")
        return
    u = User(email=email, is_admin=True)
    u.set_password(pwd)
    db.session.add(u)
    db.session.commit()
    print("Admin created.")


# -----------------------
# Compatibility / aliases
# -----------------------
@app.route("/add_tenant")
@login_required
def add_tenant_alias():
    return redirect(url_for("tenant_add"))


@app.route("/edit_tenant/<int:tenant_id>")
@login_required
def edit_tenant_alias(tenant_id):
    return redirect(url_for("tenant_edit", tenant_id=tenant_id))


@app.route("/add_payment")
@login_required
def add_payment_alias():
    tenant_id = request.args.get("tenant_id")
    if tenant_id:
        return redirect(url_for("payment_add", tenant_id=tenant_id))
    return redirect(url_for("payment_list"))


@app.route("/payment/edit-redirect")
@login_required
def payment_edit_redirect():
    return redirect(url_for("payment_list"))



with app.app_context():
    try:
        db.create_all()
        print("‚úÖ Database initialized successfully.")
    except Exception as e:
        print("‚ùå Database initialization failed:", e)

        

# at the bottom of app.py (add only these lines)
try:
    import landlord_settings  # registers /settings/payment and defines LandlordSettings model
except Exception as e:
    print("Failed to import landlord_settings:", e)



def create_app():
    app = Flask(__name__)
    # load env vars or config here as needed
    app.register_blueprint(mpesa_bp)  # mounts /mpesa_callback/*

    # Ensure DB and payment table exist on startup
    try:
        conn = _connect()
        conn.close()
    except Exception as e:
        app.logger.error("Failed to initialize DB: %s", e)

    return app

# Backward-compatible alias for legacy imports
process_payment = process_direct_payment

app.register_blueprint(mpesa_bp)



if __name__ == "__main__":
    app = create_app()
    # note: for production use gunicorn + reverse proxy; flask run is fine for sandbox
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 5000)))


    


